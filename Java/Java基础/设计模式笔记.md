# 设计模式笔记

总的来说，是一些==惯用法==，让程序更加灵活、更具扩展性！

## 适应设计

- 迭代器
- 适配器

## 交给子类

- 模版方法（父类可以组合使用被子类继承的一些方法，避免子类重复写逻辑）
- 工厂方法（抽象的工厂类生成抽象的产品类，实现抽象工厂类的子类生成实际的产品类）

## 生成实例

- 单例模式（饿汉式，双重检定）
- 原型模式（clone）
- 建造者模式（构造函数参数众多时，用辅助类创建）
- 抽象工厂模式（抽象工厂生成多个不同类型的抽象产品类，实现抽象方法的子类生成多个不同类型的实习产品）

## 分开考虑

- 桥接模式（在抽象类中，使用组合的方式持有一个接口的引用。这样子类的实现和接口的具体实现都是可以分开考虑的。实现了解耦）
- 策略模式（持有一个策略的接口，使用接口来实现本类功能，将使用策略和策略的实现解耦）

## 一致性

- 组合模式（Composite，抽象的父类，实现的子类分为叶子和节点，节点可以包含多个抽象类，类比文件系统）
- 装饰模式（对一个接口继承，继承的接口内部持有原接口的引用，然后实现类中除了调用原接口的方法外，可以自由添加额外的语句，相当于python的高阶函数）

## 访问数据接口

- 访问器模式（一个结构A持有元素列表，元素有公共接口且有不同类型；A有个方法叫访问，接受一个访问者接口的参数，对每个元素都会执行访问者接口的访问函数；访问者接口的函数有N个重载每个重载对应一个元素类型；访问者接口有多种实现）
- 责任链（类似MVC的拦截器）

## 简单化

- 外观模式（  为一个复杂子系统提供一个简单接口）
- 中介者模式（在处理GUI界面时很有用，可以根据组件的状态来实施不同变化，==我之前在写GUI时就遇到这个问题，写的很乱==）

## 管理状态

- 观察者模式（通过抽象父类持有观察者接口的引用，在变化时向观察者报告变化）
- 备忘录模式
- 状态模式（用接口的子类来表示状态）

## 避免浪费

- 轻量模式/享元模式 （复用对象，避免重复创建，对象池）
- 代理模式

## 用类来表现

- 命令模式（将请求以命令的形式包裹在对象中，并传递给对象，调用对象寻找到处理该命令的合适的对象，并将该命令传递给相应的对象，该对象执行。）
- 解释器模式（可以将一个需要解释执行的语言中的句子表示为一个抽象语法树）